"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateMetadata = exports.getUpdateMetadataParams = void 0;
const updateBatchBaseURI_js_1 = require("../../__generated__/DropERC721/write/updateBatchBaseURI.js");
const getBaseURICount_js_1 = require("../../__generated__/IBatchMintMetadata/read/getBaseURICount.js");
/**
 * @internal
 */
async function getUpdateMetadataParams(options) {
    const { contract, targetTokenId, newMetadata, client } = options;
    const batchCount = await (0, getBaseURICount_js_1.getBaseURICount)(options);
    if (batchCount === 0n) {
        throw new Error("No base URI set. Please set a base URI before updating metadata");
    }
    // Look for the batchId & determine the start + end tokenId of the batch
    const [{ getBatchIdAtIndex }, { getNFT }] = await Promise.all([
        Promise.resolve().then(() => require("../../__generated__/IBatchMintMetadata/read/getBatchIdAtIndex.js")),
        Promise.resolve().then(() => require("../../read/getNFT.js")),
    ]);
    let startTokenId = 0n;
    let endTokenId = 0n;
    let batchIndex = 0n;
    for (let i = 0n; i < batchCount; i += 1n) {
        batchIndex = i;
        endTokenId = await getBatchIdAtIndex({ contract, index: batchIndex });
        if (endTokenId > targetTokenId) {
            break;
        }
        startTokenId = endTokenId;
    }
    const range = Array.from({ length: Number(endTokenId - startTokenId) }, (_, k) => BigInt(k) + startTokenId);
    const currentMetadatas = await Promise.all(range.map((id) => getNFT({ contract, tokenId: id, includeOwner: false })));
    // Abort if any of the items failed to load
    if (currentMetadatas.some((item) => item === undefined || !item.tokenURI)) {
        throw new Error(`Failed to load all ${range.length} items from batchIndex: ${batchIndex}`);
    }
    const newMetadatas = [];
    for (let i = 0; i < currentMetadatas.length; i++) {
        const { id, metadata } = currentMetadatas[i];
        if (targetTokenId === id) {
            newMetadatas.push(newMetadata);
        }
        else {
            newMetadatas.push(metadata);
        }
    }
    const { uploadOrExtractURIs } = await Promise.resolve().then(() => require("../../../../utils/ipfs.js"));
    const batchOfUris = await uploadOrExtractURIs(newMetadatas, client, Number(startTokenId));
    if (!batchOfUris || !batchOfUris.length || !batchOfUris[0]) {
        throw new Error("Failed to upload batch of new metadatas");
    }
    const baseUri = batchOfUris[0].substring(0, batchOfUris[0].lastIndexOf("/"));
    // IMPORTANT: The new ipfs URI must have the trailing slash at the end
    // this is required by the Drop contract
    const uri = `${baseUri}/`;
    return { index: batchIndex, uri };
}
exports.getUpdateMetadataParams = getUpdateMetadataParams;
/**
 * Update the metadata of the single token in an NFT Drop (DropERC721) collection
 * For NFT Collection, please use `setTokenURI`
 * @param options
 * @returns the prepared transaction
 * @extension ERC721
 * @example
 * ```ts
 * import { updateMetadata } from "thirdweb/extensions/erc721";
 *
 * const transaction = updateMetadata({
 *  contract,
 *  targetTokenId: 0n,
 *  newMetadata: {
 *    name: "this is the new nft name",
 *    description: "...",
 *    image: "new image uri"
 *    // ...
 *  }
 * });
 * ```
 */
function updateMetadata(options) {
    const { contract } = options;
    return (0, updateBatchBaseURI_js_1.updateBatchBaseURI)({
        contract,
        asyncParams: async () => getUpdateMetadataParams(options),
    });
}
exports.updateMetadata = updateMetadata;
//# sourceMappingURL=updateMetadata.js.map