"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useSendCallsCore = void 0;
const react_query_1 = require("@tanstack/react-query");
const send_calls_js_1 = require("../../../../wallets/eip5792/send-calls.js");
const wait_for_bundle_js_1 = require("../../../../wallets/eip5792/wait-for-bundle.js");
const invalidateWalletBalance_js_1 = require("../../providers/invalidateWalletBalance.js");
function useSendCallsCore({ client, waitForResult = true, }, wallet) {
    const connectedWallet = wallet;
    const queryClient = (0, react_query_1.useQueryClient)();
    return (0, react_query_1.useMutation)({
        mutationFn: async (options) => {
            const { wallet = connectedWallet } = options;
            const chain = wallet?.getChain();
            if (!wallet || !chain) {
                throw new Error("Failed to send transactions, no connected wallet found.");
            }
            const callsPromise = (0, send_calls_js_1.sendCalls)({ ...options, wallet });
            if (!waitForResult) {
                return callsPromise;
            }
            const result = await (0, wait_for_bundle_js_1.waitForBundle)({
                bundleId: await callsPromise,
                wallet,
                client,
                chain,
            });
            return result;
        },
        onSettled: async (_result, _error, variables) => {
            // Attempt to invalidate any reads related to the sent transactions
            const chain = connectedWallet?.getChain();
            if (!_result || !connectedWallet || !chain) {
                return;
            }
            if (typeof _result === "string") {
                await (0, wait_for_bundle_js_1.waitForBundle)({
                    bundleId: _result,
                    wallet: connectedWallet,
                    client,
                    chain,
                }).catch((error) => {
                    console.error("Failed to confirm sent bundle and invalidate queries", _result, error);
                    return undefined;
                });
            }
            for (const call of variables.calls) {
                queryClient.invalidateQueries({
                    queryKey: [
                        "readContract",
                        call.__contract?.chain.id,
                        call.__contract?.address,
                    ],
                });
            }
            (0, invalidateWalletBalance_js_1.invalidateWalletBalance)(queryClient, chain.id);
        },
    });
}
exports.useSendCallsCore = useSendCallsCore;
//# sourceMappingURL=useSendCalls.js.map