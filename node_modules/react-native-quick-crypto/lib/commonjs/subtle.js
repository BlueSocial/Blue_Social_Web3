"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.subtle = void 0;
var _keys = require("./keys");
var _Utils = require("./Utils");
var _ec = require("./ec");
var _pbkdf = require("./pbkdf2");
var _Hash = require("./Hash");
var _aes = require("./aes");
var _rsa = require("./rsa");
const exportKeySpki = async key => {
  switch (key.algorithm.name) {
    // case 'RSASSA-PKCS1-v1_5':
    // // Fall through
    // case 'RSA-PSS':
    // // Fall through
    // case 'RSA-OAEP':
    //   if (key.type === 'public') {
    //     return require('internal/crypto/rsa').rsaExportKey(
    //       key,
    //       kWebCryptoKeyFormatSPKI
    //     );
    //   }
    //   break;
    case 'ECDSA':
    // Fall through
    case 'ECDH':
      if (key.type === 'public') {
        return (0, _ec.ecExportKey)(key, _keys.KWebCryptoKeyFormat.kWebCryptoKeyFormatSPKI);
      }
      break;
    // case 'Ed25519':
    // // Fall through
    // case 'Ed448':
    // // Fall through
    // case 'X25519':
    // // Fall through
    // case 'X448':
    //   if (key.type === 'public') {
    //     return require('internal/crypto/cfrg').cfrgExportKey(
    //       key,
    //       kWebCryptoKeyFormatSPKI
    //     );
    //   }
    //   break;
  }
  throw new Error(`Unable to export a raw ${key.algorithm.name} ${key.type} key`);
};
const exportKeyRaw = key => {
  switch (key.algorithm.name) {
    case 'ECDSA':
    // Fall through
    case 'ECDH':
      if (key.type === 'public') {
        return (0, _ec.ecExportKey)(key, _keys.KWebCryptoKeyFormat.kWebCryptoKeyFormatRaw);
      }
      break;
    // case 'Ed25519':
    //   // Fall through
    // case 'Ed448':
    //   // Fall through
    // case 'X25519':
    //   // Fall through
    // case 'X448':
    //   if (key.type === 'public') {
    //     return require('internal/crypto/cfrg')
    //       .cfrgExportKey(key, kWebCryptoKeyFormatRaw);
    //   }
    //   break;
    case 'AES-CTR':
    // Fall through
    case 'AES-CBC':
    // Fall through
    case 'AES-GCM':
    // Fall through
    case 'AES-KW':
    // Fall through
    case 'HMAC':
      return key.keyObject.export();
  }
  throw (0, _Utils.lazyDOMException)(`Unable to export a raw ${key.algorithm.name} ${key.type} key`, 'InvalidAccessError');
};
const exportKeyJWK = key => {
  const jwk = key.keyObject.handle.exportJwk({
    key_ops: key.usages,
    ext: key.extractable
  }, true);
  switch (key.algorithm.name) {
    case 'RSASSA-PKCS1-v1_5':
      jwk.alg = (0, _Utils.normalizeHashName)(key.algorithm.hash, _Utils.HashContext.JwkRsa);
      return jwk;
    case 'RSA-PSS':
      jwk.alg = (0, _Utils.normalizeHashName)(key.algorithm.hash, _Utils.HashContext.JwkRsaPss);
      return jwk;
    case 'RSA-OAEP':
      jwk.alg = (0, _Utils.normalizeHashName)(key.algorithm.hash, _Utils.HashContext.JwkRsaOaep);
      return jwk;
    case 'ECDSA':
    // Fall through
    case 'ECDH':
      jwk.crv ||= key.algorithm.namedCurve;
      return jwk;
    // case 'X25519':
    //   // Fall through
    // case 'X448':
    //   jwk.crv ||= key.algorithm.name;
    //   return jwk;
    // case 'Ed25519':
    //   // Fall through
    // case 'Ed448':
    //   jwk.crv ||= key.algorithm.name;
    //   return jwk;
    case 'AES-CTR':
    // Fall through
    case 'AES-CBC':
    // Fall through
    case 'AES-GCM':
    // Fall through
    case 'AES-KW':
      jwk.alg = (0, _aes.getAlgorithmName)(key.algorithm.name, key.algorithm.length);
      return jwk;
    // case 'HMAC':
    //   jwk.alg = normalizeHashName(
    //     key.algorithm.hash.name,
    //     normalizeHashName.kContextJwkHmac);
    //   return jwk;
    default:
    // Fall through
  }
  throw (0, _Utils.lazyDOMException)(`JWK export not yet supported: ${key.algorithm.name}`, 'NotSupportedError');
};
const importGenericSecretKey = async ({
  name,
  length
}, format, keyData, extractable, keyUsages) => {
  if (extractable) {
    throw new Error(`${name} keys are not extractable`);
  }
  if ((0, _Utils.hasAnyNotIn)(keyUsages, ['deriveKey', 'deriveBits'])) {
    throw new Error(`Unsupported key usage for a ${name} key`);
  }
  switch (format) {
    case 'raw':
      {
        if ((0, _Utils.hasAnyNotIn)(keyUsages, ['deriveKey', 'deriveBits'])) {
          throw new Error(`Unsupported key usage for a ${name} key`);
        }
        const checkLength = typeof keyData === 'string' ? keyData.length * 8 : keyData.byteLength * 8;

        // The Web Crypto spec allows for key lengths that are not multiples of
        // 8. We don't. Our check here is stricter than that defined by the spec
        // in that we require that algorithm.length match keyData.length * 8 if
        // algorithm.length is specified.
        if (length !== undefined && length !== checkLength) {
          throw new Error('Invalid key length');
        }
        const keyObject = (0, _keys.createSecretKey)(keyData);
        return new _keys.CryptoKey(keyObject, {
          name
        }, keyUsages, false);
      }
  }
  throw new Error(`Unable to import ${name} key with format ${format}`);
};
class Subtle {
  async digest(algorithm, data) {
    const normalizedAlgorithm = (0, _Utils.normalizeAlgorithm)(algorithm, 'digest');
    return (0, _Hash.asyncDigest)(normalizedAlgorithm, data);
  }
  async deriveBits(algorithm, baseKey, length) {
    if (!baseKey.keyUsages.includes('deriveBits')) {
      throw new Error('baseKey does not have deriveBits usage');
    }
    if (baseKey.algorithm.name !== algorithm.name) throw new Error('Key algorithm mismatch');
    switch (algorithm.name) {
      // case 'X25519':
      //   // Fall through
      // case 'X448':
      //   // Fall through
      // case 'ECDH':
      //   return require('internal/crypto/diffiehellman')
      //     .ecdhDeriveBits(algorithm, baseKey, length);
      // case 'HKDF':
      //   return require('internal/crypto/hkdf')
      //     .hkdfDeriveBits(algorithm, baseKey, length);
      case 'PBKDF2':
        return (0, _pbkdf.pbkdf2DeriveBits)(algorithm, baseKey, length);
    }
    throw new Error(`'subtle.deriveBits()' for ${algorithm.name} is not implemented.`);
  }
  async importKey(format, data, algorithm, extractable, keyUsages) {
    const normalizedAlgorithm = (0, _Utils.normalizeAlgorithm)(algorithm, 'importKey');
    let result;
    switch (normalizedAlgorithm.name) {
      case 'RSASSA-PKCS1-v1_5':
      // Fall through
      case 'RSA-PSS':
      // Fall through
      case 'RSA-OAEP':
        result = (0, _rsa.rsaImportKey)(format, data, normalizedAlgorithm, extractable, keyUsages);
        break;
      case 'ECDSA':
      // Fall through
      case 'ECDH':
        result = (0, _ec.ecImportKey)(format, data, normalizedAlgorithm, extractable, keyUsages);
        break;
      // case 'Ed25519':
      // // Fall through
      // case 'Ed448':
      // // Fall through
      // case 'X25519':
      // // Fall through
      // case 'X448':
      //   result = await require('internal/crypto/cfrg').cfrgImportKey(
      //     format,
      //     keyData,
      //     algorithm,
      //     extractable,
      //     keyUsages
      //   );
      //   break;
      // case 'HMAC':
      //   result = await require('internal/crypto/mac').hmacImportKey(
      //     format,
      //     keyData,
      //     algorithm,
      //     extractable,
      //     keyUsages
      //   );
      //   break;
      case 'AES-CTR':
      // Fall through
      case 'AES-CBC':
      // Fall through
      case 'AES-GCM':
      // Fall through
      case 'AES-KW':
        result = await (0, _aes.aesImportKey)(normalizedAlgorithm, format, data, extractable, keyUsages);
        break;
      // case 'HKDF':
      // // Fall through
      case 'PBKDF2':
        result = await importGenericSecretKey(normalizedAlgorithm, format, data, extractable, keyUsages);
        break;
      default:
        throw new Error(`"subtle.importKey()" is not implemented for ${normalizedAlgorithm.name}`);
    }
    if ((result.type === 'secret' || result.type === 'private') && result.usages.length === 0) {
      throw new Error(`Usages cannot be empty when importing a ${result.type} key.`);
    }
    return result;
  }
  async exportKey(format, key) {
    if (!key.extractable) throw new Error('key is not extractable');
    switch (format) {
      case 'spki':
        return await exportKeySpki(key);
      // case 'pkcs8':
      //   return await exportKeyPkcs8(key);
      case 'jwk':
        return exportKeyJWK(key);
      case 'raw':
        return exportKeyRaw(key);
    }
    throw new Error(`'subtle.exportKey()' is not implemented for ${format}`);
  }
}
const subtle = exports.subtle = new Subtle();
//# sourceMappingURL=subtle.js.map