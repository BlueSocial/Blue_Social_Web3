"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ecExportKey = ecExportKey;
exports.ecImportKey = ecImportKey;
var _NativeQuickCrypto = require("./NativeQuickCrypto/NativeQuickCrypto");
var _Utils = require("./Utils");
var _keys = require("./keys");
// const {
//   ArrayPrototypeIncludes,
//   ObjectKeys,
//   SafeSet,
// } = primordials;

// const {
//   ECKeyExportJob,
//   KeyObjectHandle,
//   SignJob,
//   kCryptoJobAsync,
//   kKeyTypePrivate,
//   kSignJobModeSign,
//   kSignJobModeVerify,
//   kSigEncP1363,
// } = internalBinding('crypto');

// const {
//   getUsagesUnion,
//   hasAnyNotIn,
//   jobPromise,
//   normalizeHashName,
//   validateKeyOps,
//   kHandle,
//   kKeyObject,
//   kNamedCurveAliases,
// } = require('internal/crypto/util');

// const {
//   lazyDOMException,
//   promisify,
// } = require('internal/util');

// const {
//   generateKeyPair: _generateKeyPair,
// } = require('internal/crypto/keygen');

// const {
//   InternalCryptoKey,
//   PrivateKeyObject,
//   PublicKeyObject,
//   createPrivateKey,
//   createPublicKey,
// } = require('internal/crypto/keys');

// const generateKeyPair = promisify(_generateKeyPair);

function verifyAcceptableEcKeyUse(name, isPublic, usages) {
  let checkSet;
  switch (name) {
    case 'ECDH':
      checkSet = isPublic ? [] : ['deriveKey', 'deriveBits'];
      break;
    case 'ECDSA':
      checkSet = isPublic ? ['verify'] : ['sign'];
      break;
    default:
      throw (0, _Utils.lazyDOMException)('The algorithm is not supported', 'NotSupportedError');
  }
  if ((0, _Utils.hasAnyNotIn)(usages, checkSet)) {
    throw (0, _Utils.lazyDOMException)(`Unsupported key usage for a ${name} key`, 'SyntaxError');
  }
}
function createECPublicKeyRaw(namedCurve, keyData) {
  if (!namedCurve) {
    throw new Error('Invalid namedCurve');
  }
  const handle = _NativeQuickCrypto.NativeQuickCrypto.webcrypto.createKeyObjectHandle();
  if (!handle.initECRaw(_keys.kNamedCurveAliases[namedCurve], keyData)) {
    console.log('keyData', (0, _Utils.ab2str)(keyData));
    throw new Error('Invalid keyData 1');
  }
  return new _keys.PublicKeyObject(handle);
}

// async function ecGenerateKey(algorithm, extractable, keyUsages) {
//   const { name, namedCurve } = algorithm;

//   if (!ArrayPrototypeIncludes(ObjectKeys(kNamedCurveAliases), namedCurve)) {
//     throw lazyDOMException(
//       'Unrecognized namedCurve',
//       'NotSupportedError');
//   }

//   const usageSet = new SafeSet(keyUsages);
//   switch (name) {
//     case 'ECDSA':
//       if (hasAnyNotIn(usageSet, ['sign', 'verify'])) {
//         throw lazyDOMException(
//           'Unsupported key usage for an ECDSA key',
//           'SyntaxError');
//       }
//       break;
//     case 'ECDH':
//       if (hasAnyNotIn(usageSet, ['deriveKey', 'deriveBits'])) {
//         throw lazyDOMException(
//           'Unsupported key usage for an ECDH key',
//           'SyntaxError');
//       }
//       // Fall through
//   }

//   const keypair = await generateKeyPair('ec', { namedCurve }).catch((err) => {
//     throw lazyDOMException(
//       'The operation failed for an operation-specific reason',
//       { name: 'OperationError', cause: err });
//   });

//   let publicUsages;
//   let privateUsages;
//   switch (name) {
//     case 'ECDSA':
//       publicUsages = getUsagesUnion(usageSet, 'verify');
//       privateUsages = getUsagesUnion(usageSet, 'sign');
//       break;
//     case 'ECDH':
//       publicUsages = [];
//       privateUsages = getUsagesUnion(usageSet, 'deriveKey', 'deriveBits');
//       break;
//   }

//   const keyAlgorithm = { name, namedCurve };

//   const publicKey =
//     new InternalCryptoKey(
//       keypair.publicKey,
//       keyAlgorithm,
//       publicUsages,
//       true);

//   const privateKey =
//     new InternalCryptoKey(
//       keypair.privateKey,
//       keyAlgorithm,
//       privateUsages,
//       extractable);

//   return { __proto__: null, publicKey, privateKey };
// }

function ecExportKey(key, format) {
  return _NativeQuickCrypto.NativeQuickCrypto.webcrypto.ecExportKey(format, key.keyObject.handle);
}
function ecImportKey(format, keyData, algorithm, extractable, keyUsages) {
  const {
    name,
    namedCurve
  } = algorithm;

  // if (!ArrayPrototypeIncludes(ObjectKeys(kNamedCurveAliases), namedCurve)) {
  //   throw lazyDOMException('Unrecognized namedCurve', 'NotSupportedError');
  // }

  let keyObject;
  // const usagesSet = new SafeSet(keyUsages);
  switch (format) {
    // case 'spki': {
    //   // verifyAcceptableEcKeyUse(name, true, usagesSet);
    //   try {
    //     keyObject = createPublicKey({
    //       key: keyData,
    //       format: 'der',
    //       type: 'spki',
    //     });
    //   } catch (err) {
    //     throw new Error(`Invalid keyData 2: ${err}`);
    //   }
    //   break;
    // }
    // case 'pkcs8': {
    //   // verifyAcceptableEcKeyUse(name, false, usagesSet);
    //   try {
    //     keyObject = createPrivateKey({
    //       key: keyData,
    //       format: 'der',
    //       type: 'pkcs8',
    //     });
    //   } catch (err) {
    //     throw new Error(`Invalid keyData 3 ${err}`);
    //   }
    //   break;
    // }
    case 'jwk':
      {
        const data = keyData;
        if (!data.kty) throw (0, _Utils.lazyDOMException)('Invalid keyData 4', 'DataError');
        if (data.kty !== 'EC') throw (0, _Utils.lazyDOMException)('Invalid JWK "kty" Parameter', 'DataError');
        if (data.crv !== namedCurve) throw (0, _Utils.lazyDOMException)('JWK "crv" does not match the requested algorithm', 'DataError');
        verifyAcceptableEcKeyUse(name, data.d === undefined, keyUsages);
        if (keyUsages.length > 0 && data.use !== undefined) {
          const checkUse = name === 'ECDH' ? 'enc' : 'sig';
          if (data.use !== checkUse) throw (0, _Utils.lazyDOMException)('Invalid JWK "use" Parameter', 'DataError');
        }
        (0, _Utils.validateKeyOps)(data.key_ops, keyUsages);
        if (data.ext !== undefined && data.ext === false && extractable === true) {
          throw (0, _Utils.lazyDOMException)('JWK "ext" Parameter and extractable mismatch', 'DataError');
        }
        if (algorithm.name === 'ECDSA' && data.alg !== undefined) {
          let algNamedCurve;
          switch (data.alg) {
            case 'ES256':
              algNamedCurve = 'P-256';
              break;
            case 'ES384':
              algNamedCurve = 'P-384';
              break;
            case 'ES512':
              algNamedCurve = 'P-521';
              break;
          }
          if (algNamedCurve !== namedCurve) throw (0, _Utils.lazyDOMException)('JWK "alg" does not match the requested algorithm', 'DataError');
        }
        const handle = _NativeQuickCrypto.NativeQuickCrypto.webcrypto.createKeyObjectHandle();
        const type = handle.initJwk(data, namedCurve);
        if (type === undefined) throw (0, _Utils.lazyDOMException)('Invalid JWK', 'DataError');
        keyObject = type === _keys.KeyType.Private ? new _keys.PrivateKeyObject(handle) : new _keys.PublicKeyObject(handle);
        break;
      }
    case 'raw':
      {
        const data = keyData;
        verifyAcceptableEcKeyUse(name, true, keyUsages);
        let buffer = typeof data === 'string' ? (0, _Utils.binaryLikeToArrayBuffer)(data) : (0, _Utils.bufferLikeToArrayBuffer)(data);
        keyObject = createECPublicKeyRaw(namedCurve, buffer);
        break;
      }
    default:
      {
        throw new Error(`Unknown EC import format: ${format}`);
      }
  }
  switch (algorithm.name) {
    case 'ECDSA':
    // Fall through
    case 'ECDH':
      // if (keyObject.asymmetricKeyType !== 'ec')
      //   throw new Error('Invalid key type');
      break;
  }

  // if (!keyObject[kHandle].checkEcKeyData()) {
  //   throw new Error('Invalid keyData 5');
  // }

  // const { namedCurve: checkNamedCurve } = keyObject[kHandle].keyDetail({});
  // if (kNamedCurveAliases[namedCurve] !== checkNamedCurve)
  //   throw new Error('Named curve mismatch');

  return new _keys.CryptoKey(keyObject, {
    name,
    namedCurve
  }, keyUsages, extractable);
}

// function ecdsaSignVerify(key, data, { name, hash }, signature) {
//   const mode = signature === undefined ? kSignJobModeSign : kSignJobModeVerify;
//   const type = mode === kSignJobModeSign ? 'private' : 'public';

//   if (key.type !== type)
//     throw lazyDOMException(`Key must be a ${type} key`, 'InvalidAccessError');

//   const hashname = normalizeHashName(hash.name);

//   return jobPromise(() => new SignJob(
//     kCryptoJobAsync,
//     mode,
//     key[kKeyObject][kHandle],
//     undefined,
//     undefined,
//     undefined,
//     data,
//     hashname,
//     undefined,  // Salt length, not used with ECDSA
//     undefined,  // PSS Padding, not used with ECDSA
//     kSigEncP1363,
//     signature));
// }
//# sourceMappingURL=ec.js.map