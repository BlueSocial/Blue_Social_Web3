import { type BinaryLike } from './Utils';
import type { KeyObjectHandle } from './NativeQuickCrypto/webcrypto';
export declare const kNamedCurveAliases: {
    readonly 'P-256': "prime256v1";
    readonly 'P-384': "secp384r1";
    readonly 'P-521': "secp521r1";
};
export type NamedCurve = 'P-256' | 'P-384' | 'P-521';
export type ImportFormat = 'raw' | 'pkcs8' | 'spki' | 'jwk';
export type AnyAlgorithm = HashAlgorithm | KeyPairAlgorithm | SecretKeyAlgorithm | SignVerifyAlgorithm | DeriveBitsAlgorithm | EncryptDecryptAlgorithm | 'PBKDF2' | 'HKDF';
export type HashAlgorithm = 'SHA-1' | 'SHA-256' | 'SHA-384' | 'SHA-512';
export type KeyPairAlgorithm = 'ECDSA' | 'ECDH' | 'Ed25519' | 'Ed448' | 'RSASSA-PKCS1-v1_5' | 'RSA-PSS' | 'RSA-OAEP' | 'X25519' | 'X448';
export type SecretKeyAlgorithm = 'HMAC' | 'AES-CTR' | 'AES-CBC' | 'AES-GCM' | 'AES-KW';
export type SignVerifyAlgorithm = 'RSASSA-PKCS1-v1_5' | 'RSA-PSS' | 'ECDSA' | 'HMAC' | 'Ed25519' | 'Ed448';
export type DeriveBitsAlgorithm = 'PBKDF2' | 'HKDF' | 'ECDH' | 'X25519' | 'X448';
export type EncryptDecryptAlgorithm = 'RSA-OAEP' | 'AES-CTR' | 'AES-CBC' | 'AES-GCM';
export type SubtleAlgorithm = {
    name: AnyAlgorithm;
    salt?: string;
    iterations?: number;
    hash?: HashAlgorithm;
    namedCurve?: NamedCurve;
    length?: number;
    modulusLength?: number;
    publicExponent?: any;
};
export type KeyUsage = 'encrypt' | 'decrypt' | 'sign' | 'verify' | 'deriveKey' | 'deriveBits' | 'wrapKey' | 'unwrapKey';
export declare enum KFormatType {
    kKeyFormatDER = 0,
    kKeyFormatPEM = 1,
    kKeyFormatJWK = 2
}
export declare enum KeyType {
    Secret = 0,
    Public = 1,
    Private = 2
}
export declare enum KWebCryptoKeyFormat {
    kWebCryptoKeyFormatRaw = 0,
    kWebCryptoKeyFormatPKCS8 = 1,
    kWebCryptoKeyFormatSPKI = 2,
    kWebCryptoKeyFormatJWK = 3
}
export declare enum WebCryptoKeyExportStatus {
    OK = 0,
    INVALID_KEY_TYPE = 1,
    FAILED = 2
}
export declare enum KeyEncoding {
    kKeyEncodingPKCS1 = 0,
    kKeyEncodingPKCS8 = 1,
    kKeyEncodingSPKI = 2,
    kKeyEncodingSEC1 = 3
}
export type EncodingOptions = {
    key: any;
    type?: string;
    encoding?: string;
    format?: string;
    padding?: number;
    cipher?: string;
    passphrase?: string | ArrayBuffer;
};
export type AsymmetricKeyType = 'rsa' | 'rsa-pss' | 'dsa' | 'ec' | undefined;
export type JWK = {
    'kty'?: 'AES' | 'RSA' | 'EC' | 'oct';
    'use'?: 'sig' | 'enc';
    'key_ops'?: KeyUsage[];
    'alg'?: string;
    'crv'?: string;
    'kid'?: string;
    'x5u'?: string;
    'x5c'?: string[];
    'x5t'?: string;
    'x5t#256'?: string;
    'n'?: string;
    'e'?: string;
    'd'?: string;
    'p'?: string;
    'q'?: string;
    'x'?: string;
    'y'?: string;
    'k'?: string;
    'dp'?: string;
    'dq'?: string;
    'qi'?: string;
    'ext'?: boolean;
};
export declare function preparePrivateKey(key: BinaryLike | EncodingOptions): {
    format: KFormatType;
    data: ArrayBuffer;
    type?: KeyEncoding | undefined;
    passphrase?: string | ArrayBuffer | undefined;
};
export declare function preparePublicOrPrivateKey(key: BinaryLike | {
    key: any;
    encoding?: string;
    format?: any;
    padding?: number;
}): {
    format: KFormatType;
    data: ArrayBuffer;
    type?: KeyEncoding | undefined;
    passphrase?: string | ArrayBuffer | undefined;
};
export declare function parsePublicKeyEncoding(enc: EncodingOptions, keyType: string | undefined, objName?: string): {
    format: KFormatType;
    type: KeyEncoding | undefined;
    cipher: string | undefined;
    passphrase: ArrayBuffer | undefined;
};
export declare function parsePrivateKeyEncoding(enc: EncodingOptions, keyType: string | undefined, objName?: string): {
    format: KFormatType;
    type: KeyEncoding | undefined;
    cipher: string | undefined;
    passphrase: ArrayBuffer | undefined;
};
export declare function createSecretKey(key: any, encoding?: string): SecretKeyObject;
export declare class CryptoKey {
    keyObject: KeyObject;
    keyAlgorithm: SubtleAlgorithm;
    keyUsages: KeyUsage[];
    keyExtractable: boolean;
    constructor(keyObject: KeyObject, keyAlgorithm: SubtleAlgorithm, keyUsages: KeyUsage[], keyExtractable: boolean);
    inspect(_depth: number, _options: any): any;
    get type(): "public" | "secret" | "private" | "unknown";
    get extractable(): boolean;
    get algorithm(): SubtleAlgorithm;
    get usages(): KeyUsage[];
}
declare class KeyObject {
    handle: KeyObjectHandle;
    type: 'public' | 'secret' | 'private' | 'unknown';
    export(_options?: EncodingOptions): ArrayBuffer;
    constructor(type: string, handle: KeyObjectHandle);
}
export declare class SecretKeyObject extends KeyObject {
    constructor(handle: KeyObjectHandle);
    export(options: EncodingOptions): ArrayBuffer;
}
declare class AsymmetricKeyObject extends KeyObject {
    constructor(type: string, handle: KeyObjectHandle);
    get asymmetricKeyType(): AsymmetricKeyType;
}
export declare class PublicKeyObject extends AsymmetricKeyObject {
    constructor(handle: KeyObjectHandle);
    export(options: EncodingOptions): ArrayBuffer;
}
export declare class PrivateKeyObject extends AsymmetricKeyObject {
    constructor(handle: KeyObjectHandle);
    export(options: EncodingOptions): ArrayBuffer;
}
export {};
//# sourceMappingURL=keys.d.ts.map