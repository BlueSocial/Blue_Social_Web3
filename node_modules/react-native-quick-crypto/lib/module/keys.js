import { binaryLikeToArrayBuffer, isStringOrBuffer } from './Utils';
import { NativeQuickCrypto } from './NativeQuickCrypto/NativeQuickCrypto';
export const kNamedCurveAliases = {
  'P-256': 'prime256v1',
  'P-384': 'secp384r1',
  'P-521': 'secp521r1'
};
// On node this value is defined on the native side, for now I'm just creating it here in JS
// TODO(osp) move this into native side to make sure they always match
export let KFormatType = /*#__PURE__*/function (KFormatType) {
  KFormatType[KFormatType["kKeyFormatDER"] = 0] = "kKeyFormatDER";
  KFormatType[KFormatType["kKeyFormatPEM"] = 1] = "kKeyFormatPEM";
  KFormatType[KFormatType["kKeyFormatJWK"] = 2] = "kKeyFormatJWK";
  return KFormatType;
}({});

// Same as KFormatType, this enum needs to be defined on the native side
export let KeyType = /*#__PURE__*/function (KeyType) {
  KeyType[KeyType["Secret"] = 0] = "Secret";
  KeyType[KeyType["Public"] = 1] = "Public";
  KeyType[KeyType["Private"] = 2] = "Private";
  return KeyType;
}({});

// Same as KFormatType, this enum needs to be defined on the native side
export let KWebCryptoKeyFormat = /*#__PURE__*/function (KWebCryptoKeyFormat) {
  KWebCryptoKeyFormat[KWebCryptoKeyFormat["kWebCryptoKeyFormatRaw"] = 0] = "kWebCryptoKeyFormatRaw";
  KWebCryptoKeyFormat[KWebCryptoKeyFormat["kWebCryptoKeyFormatPKCS8"] = 1] = "kWebCryptoKeyFormatPKCS8";
  KWebCryptoKeyFormat[KWebCryptoKeyFormat["kWebCryptoKeyFormatSPKI"] = 2] = "kWebCryptoKeyFormatSPKI";
  KWebCryptoKeyFormat[KWebCryptoKeyFormat["kWebCryptoKeyFormatJWK"] = 3] = "kWebCryptoKeyFormatJWK";
  return KWebCryptoKeyFormat;
}({});
export let WebCryptoKeyExportStatus = /*#__PURE__*/function (WebCryptoKeyExportStatus) {
  WebCryptoKeyExportStatus[WebCryptoKeyExportStatus["OK"] = 0] = "OK";
  WebCryptoKeyExportStatus[WebCryptoKeyExportStatus["INVALID_KEY_TYPE"] = 1] = "INVALID_KEY_TYPE";
  WebCryptoKeyExportStatus[WebCryptoKeyExportStatus["FAILED"] = 2] = "FAILED";
  return WebCryptoKeyExportStatus;
}({});
var KeyInputContext = /*#__PURE__*/function (KeyInputContext) {
  KeyInputContext[KeyInputContext["kConsumePublic"] = 0] = "kConsumePublic";
  KeyInputContext[KeyInputContext["kConsumePrivate"] = 1] = "kConsumePrivate";
  KeyInputContext[KeyInputContext["kCreatePublic"] = 2] = "kCreatePublic";
  KeyInputContext[KeyInputContext["kCreatePrivate"] = 3] = "kCreatePrivate";
  return KeyInputContext;
}(KeyInputContext || {});
export let KeyEncoding = /*#__PURE__*/function (KeyEncoding) {
  KeyEncoding[KeyEncoding["kKeyEncodingPKCS1"] = 0] = "kKeyEncodingPKCS1";
  KeyEncoding[KeyEncoding["kKeyEncodingPKCS8"] = 1] = "kKeyEncodingPKCS8";
  KeyEncoding[KeyEncoding["kKeyEncodingSPKI"] = 2] = "kKeyEncodingSPKI";
  KeyEncoding[KeyEncoding["kKeyEncodingSEC1"] = 3] = "kKeyEncodingSEC1";
  return KeyEncoding;
}({});
const encodingNames = {
  [KeyEncoding.kKeyEncodingPKCS1]: 'pkcs1',
  [KeyEncoding.kKeyEncodingPKCS8]: 'pkcs8',
  [KeyEncoding.kKeyEncodingSPKI]: 'spki',
  [KeyEncoding.kKeyEncodingSEC1]: 'sec1'
};
function option(name, objName) {
  return objName === undefined ? `options.${name}` : `options.${objName}.${name}`;
}
function parseKeyFormat(formatStr, defaultFormat, optionName) {
  if (formatStr === undefined && defaultFormat !== undefined) return defaultFormat;else if (formatStr === 'pem') return KFormatType.kKeyFormatPEM;else if (formatStr === 'der') return KFormatType.kKeyFormatDER;else if (formatStr === 'jwk') return KFormatType.kKeyFormatJWK;
  throw new Error(`Invalid key format str: ${optionName}`);
  // throw new ERR_INVALID_ARG_VALUE(optionName, formatStr);
}
function parseKeyType(typeStr, required, keyType, isPublic, optionName) {
  if (typeStr === undefined && !required) {
    return undefined;
  } else if (typeStr === 'pkcs1') {
    if (keyType !== undefined && keyType !== 'rsa') {
      throw new Error(`Crypto incompatible key options: ${typeStr} can only be used for RSA keys`);
    }
    return KeyEncoding.kKeyEncodingPKCS1;
  } else if (typeStr === 'spki' && isPublic !== false) {
    return KeyEncoding.kKeyEncodingSPKI;
  } else if (typeStr === 'pkcs8' && isPublic !== true) {
    return KeyEncoding.kKeyEncodingPKCS8;
  } else if (typeStr === 'sec1' && isPublic !== true) {
    if (keyType !== undefined && keyType !== 'ec') {
      throw new Error(`Incompatible key options ${typeStr} can only be used for EC keys`);
    }
    return KeyEncoding.kKeyEncodingSEC1;
  }
  throw new Error(`Invalid option ${optionName} - ${typeStr}`);
}
function parseKeyFormatAndType(enc, keyType, isPublic, objName) {
  const {
    format: formatStr,
    type: typeStr
  } = enc;
  const isInput = keyType === undefined;
  const format = parseKeyFormat(formatStr, isInput ? KFormatType.kKeyFormatPEM : undefined, option('format', objName));
  const isRequired = (!isInput || format === KFormatType.kKeyFormatDER) && format !== KFormatType.kKeyFormatJWK;
  const type = parseKeyType(typeStr, isRequired, keyType, isPublic, option('type', objName));
  return {
    format,
    type
  };
}
function parseKeyEncoding(enc, keyType, isPublic, objName) {
  // validateObject(enc, 'options');

  const isInput = keyType === undefined;
  const {
    format,
    type
  } = parseKeyFormatAndType(enc, keyType, isPublic, objName);
  let cipher, passphrase, encoding;
  if (isPublic !== true) {
    ({
      cipher,
      passphrase,
      encoding
    } = enc);
    if (!isInput) {
      if (cipher != null) {
        if (typeof cipher !== 'string') throw new Error(`Invalid argument ${option('cipher', objName)}: ${cipher}`);
        if (format === KFormatType.kKeyFormatDER && (type === KeyEncoding.kKeyEncodingPKCS1 || type === KeyEncoding.kKeyEncodingSEC1)) {
          throw new Error(`Incompatible key options ${encodingNames[type]} does not support encryption`);
        }
      } else if (passphrase !== undefined) {
        throw new Error(`invalid argument ${option('cipher', objName)}: ${cipher}`);
      }
    }
    if (isInput && passphrase !== undefined && !isStringOrBuffer(passphrase) || !isInput && cipher != null && !isStringOrBuffer(passphrase)) {
      throw new Error(`Invalid argument value ${option('passphrase', objName)}: ${passphrase}`);
    }
  }
  if (passphrase !== undefined) passphrase = binaryLikeToArrayBuffer(passphrase, encoding);
  return {
    format,
    type,
    cipher,
    passphrase
  };
}
function prepareAsymmetricKey(key, ctx) {
  // TODO(osp) check, KeyObject some node object
  // if (isKeyObject(key)) {
  //   // Best case: A key object, as simple as that.
  //   return { data: getKeyObjectHandle(key, ctx) };
  // } else
  // if (isCryptoKey(key)) {
  //   return { data: getKeyObjectHandle(key[kKeyObject], ctx) };
  // } else
  if (isStringOrBuffer(key)) {
    // Expect PEM by default, mostly for backward compatibility.
    return {
      format: KFormatType.kKeyFormatPEM,
      data: binaryLikeToArrayBuffer(key)
    };
  } else if (typeof key === 'object') {
    const {
      key: data,
      encoding
      // format
    } = key;
    // // The 'key' property can be a KeyObject as well to allow specifying
    // // additional options such as padding along with the key.
    // if (isKeyObject(data)) return { data: getKeyObjectHandle(data, ctx) };
    // else if (isCryptoKey(data))
    //   return { data: getKeyObjectHandle(data[kKeyObject], ctx) };
    // else if (isJwk(data) && format === 'jwk')
    //   return { data: getKeyObjectHandleFromJwk(data, ctx), format: 'jwk' };
    // Either PEM or DER using PKCS#1 or SPKI.
    if (!isStringOrBuffer(data)) {
      throw new Error('prepareAsymmetricKey: key is not a string or ArrayBuffer');
    }
    const isPublic = ctx === KeyInputContext.kConsumePrivate || ctx === KeyInputContext.kCreatePrivate ? false : undefined;
    return {
      data: binaryLikeToArrayBuffer(data, encoding),
      ...parseKeyEncoding(key, undefined, isPublic)
    };
  }
  throw new Error('[prepareAsymetricKey] Invalid argument key: ${key}');
}

// TODO(osp) any here is a node KeyObject
export function preparePrivateKey(key) {
  return prepareAsymmetricKey(key, KeyInputContext.kConsumePrivate);
}

// TODO(osp) any here is a node KeyObject
export function preparePublicOrPrivateKey(key) {
  return prepareAsymmetricKey(key, KeyInputContext.kConsumePublic);
}

// Parses the public key encoding based on an object. keyType must be undefined
// when this is used to parse an input encoding and must be a valid key type if
// used to parse an output encoding.
export function parsePublicKeyEncoding(enc, keyType, objName) {
  return parseKeyEncoding(enc, keyType, keyType ? true : undefined, objName);
}

// Parses the private key encoding based on an object. keyType must be undefined
// when this is used to parse an input encoding and must be a valid key type if
// used to parse an output encoding.
export function parsePrivateKeyEncoding(enc, keyType, objName) {
  return parseKeyEncoding(enc, keyType, false, objName);
}
function prepareSecretKey(key, encoding, bufferOnly = false) {
  if (!bufferOnly) {
    // TODO: maybe use `key.constructor.name === 'KeyObject'` ?
    if (key instanceof KeyObject) {
      if (key.type !== 'secret') throw new Error(`invalid KeyObject type: ${key.type}, expected 'secret'`);
      return key.handle;
    }
    // TODO: maybe use `key.constructor.name === 'CryptoKey'` ?
    else if (key instanceof CryptoKey) {
      if (key.type !== 'secret') throw new Error(`invalid CryptoKey type: ${key.type}, expected 'secret'`);
      return key.keyObject.handle;
    }
  }
  if (key instanceof ArrayBuffer) {
    return key;
  }
  if (typeof key === 'string') {
    return binaryLikeToArrayBuffer(key, encoding);
  }
  throw new Error('Invalid argument type for "key". Need ArrayBuffer, KeyObject, CryptoKey, string');
}
export function createSecretKey(key, encoding) {
  const k = prepareSecretKey(key, encoding, true);
  const handle = NativeQuickCrypto.webcrypto.createKeyObjectHandle();
  handle.init(KeyType.Secret, k);
  return new SecretKeyObject(handle);
}
export class CryptoKey {
  constructor(keyObject, keyAlgorithm, keyUsages, keyExtractable) {
    this.keyObject = keyObject;
    this.keyAlgorithm = keyAlgorithm;
    this.keyUsages = keyUsages;
    this.keyExtractable = keyExtractable;
  }
  inspect(_depth, _options) {
    throw new Error('CryptoKey.inspect is not implemented');
    // if (depth < 0) return this;

    // const opts = {
    //   ...options,
    //   depth: options.depth == null ? null : options.depth - 1,
    // };

    // return `CryptoKey ${inspect(
    //   {
    //     type: this.type,
    //     extractable: this.extractable,
    //     algorithm: this.algorithm,
    //     usages: this.usages,
    //   },
    //   opts
    // )}`;
  }
  get type() {
    // if (!(this instanceof CryptoKey)) throw new Error('Invalid CryptoKey');
    return this.keyObject.type;
  }
  get extractable() {
    return this.keyExtractable;
  }
  get algorithm() {
    return this.keyAlgorithm;
  }
  get usages() {
    return this.keyUsages;
  }
}

// ObjectDefineProperties(CryptoKey.prototype, {
//   type: kEnumerableProperty,
//   extractable: kEnumerableProperty,
//   algorithm: kEnumerableProperty,
//   usages: kEnumerableProperty,
//   [SymbolToStringTag]: {
//     __proto__: null,
//     configurable: true,
//     value: 'CryptoKey',
//   },
// });

class KeyObject {
  type = 'unknown';
  export(_options) {
    return new ArrayBuffer(0);
  }
  constructor(type, handle) {
    if (type !== 'secret' && type !== 'public' && type !== 'private') throw new Error(`invalid KeyObject type: ${type}`);
    this.handle = handle;
    this.type = type;
  }

  // get type(): string {
  //   return this.type;
  // }

  // static from(key) {
  //   if (!isCryptoKey(key))
  //     throw new ERR_INVALID_ARG_TYPE('key', 'CryptoKey', key);
  //   return key[kKeyObject];
  // }

  // equals(otherKeyObject) {
  //   if (!isKeyObject(otherKeyObject)) {
  //     throw new ERR_INVALID_ARG_TYPE(
  //       'otherKeyObject',
  //       'KeyObject',
  //       otherKeyObject
  //     );
  //   }

  //   return (
  //     otherKeyObject.type === this.type &&
  //     this[kHandle].equals(otherKeyObject[kHandle])
  //   );
  // }
}

// ObjectDefineProperties(KeyObject.prototype, {
//   [SymbolToStringTag]: {
//     __proto__: null,
//     configurable: true,
//     value: 'KeyObject',
//   },
// });

export class SecretKeyObject extends KeyObject {
  constructor(handle) {
    super('secret', handle);
  }

  // get symmetricKeySize() {
  //   return this[kHandle].getSymmetricKeySize();
  // }

  export(options) {
    if (options !== undefined) {
      if (options.format === 'jwk') {
        throw new Error('SecretKey export for jwk is not implemented');
        // return this.handle.exportJwk({}, false);
      }
    }
    return this.handle.export();
  }
}

// const kAsymmetricKeyType = Symbol('kAsymmetricKeyType');
// const kAsymmetricKeyDetails = Symbol('kAsymmetricKeyDetails');

// function normalizeKeyDetails(details = {}) {
//   if (details.publicExponent !== undefined) {
//     return {
//       ...details,
//       publicExponent: bigIntArrayToUnsignedBigInt(
//         new Uint8Array(details.publicExponent)
//       ),
//     };
//   }
//   return details;
// }

class AsymmetricKeyObject extends KeyObject {
  constructor(type, handle) {
    super(type, handle);
  }
  get asymmetricKeyType() {
    return this.asymmetricKeyType || this.handle.getAsymmetricKeyType();
  }

  // get asymmetricKeyDetails() {
  //   switch (this.asymmetricKeyType) {
  //     case 'rsa':
  //     case 'rsa-pss':
  //     case 'dsa':
  //     case 'ec':
  //       return (
  //         this[kAsymmetricKeyDetails] ||
  //         (this[kAsymmetricKeyDetails] = normalizeKeyDetails(
  //           this[kHandle].keyDetail({})
  //         ))
  //       );
  //     default:
  //       return {};
  //   }
  // }
}
export class PublicKeyObject extends AsymmetricKeyObject {
  constructor(handle) {
    super('public', handle);
  }
  export(options) {
    if (options?.format === 'jwk') {
      throw new Error('PublicKey export for jwk is not implemented');
      // return this.handle.exportJwk({}, false);
    }
    const {
      format,
      type
    } = parsePublicKeyEncoding(options, this.asymmetricKeyType);
    return this.handle.export(format, type);
  }
}
export class PrivateKeyObject extends AsymmetricKeyObject {
  constructor(handle) {
    super('private', handle);
  }
  export(options) {
    if (options?.format === 'jwk') {
      if (options.passphrase !== undefined) {
        throw new Error('jwk does not support encryption');
      }
      throw new Error('PrivateKey export for jwk is not implemented');
      // return this.handle.exportJwk({}, false);
    }
    const {
      format,
      type,
      cipher,
      passphrase
    } = parsePrivateKeyEncoding(options, this.asymmetricKeyType);
    return this.handle.export(format, type, cipher, passphrase);
  }
}
//# sourceMappingURL=keys.js.map