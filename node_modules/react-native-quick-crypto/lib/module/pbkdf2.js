import { NativeQuickCrypto } from './NativeQuickCrypto/NativeQuickCrypto';
import { Buffer } from '@craftzdog/react-native-buffer';
import { binaryLikeToArrayBuffer, lazyDOMException, bufferLikeToArrayBuffer, normalizeHashName, HashContext } from './Utils';
import { promisify } from 'util';
const WRONG_PASS = 'Password must be a string, a Buffer, a typed array or a DataView';
const WRONG_SALT = `Salt must be a string, a Buffer, a typed array or a DataView`;
function sanitizeInput(input, errorMsg) {
  try {
    return binaryLikeToArrayBuffer(input);
  } catch (e) {
    throw errorMsg;
  }
}
const nativePbkdf2 = NativeQuickCrypto.pbkdf2;
export function pbkdf2(password, salt, iterations, keylen, arg0, arg1) {
  let digest = 'SHA-1';
  let callback;
  if (typeof arg0 === 'string') {
    digest = arg0;
    if (typeof arg1 === 'function') {
      callback = arg1;
    }
  } else {
    if (typeof arg0 === 'function') {
      callback = arg0;
    }
  }
  if (callback === undefined) {
    throw new Error('No callback provided to pbkdf2');
  }
  const sanitizedPassword = sanitizeInput(password, WRONG_PASS);
  const sanitizedSalt = sanitizeInput(salt, WRONG_SALT);
  const normalizedDigest = normalizeHashName(digest, HashContext.Node);
  nativePbkdf2.pbkdf2(sanitizedPassword, sanitizedSalt, iterations, keylen, normalizedDigest).then(res => {
    callback(null, Buffer.from(res));
  }, e => {
    callback(e);
  });
}
export function pbkdf2Sync(password, salt, iterations, keylen, digest) {
  const sanitizedPassword = sanitizeInput(password, WRONG_PASS);
  const sanitizedSalt = sanitizeInput(salt, WRONG_SALT);
  const algo = digest ? normalizeHashName(digest, HashContext.Node) : 'sha1';
  let result = nativePbkdf2.pbkdf2Sync(sanitizedPassword, sanitizedSalt, iterations, keylen, algo);
  return Buffer.from(result);
}

// We need this because the typescript  overload signatures in pbkdf2() above do
// not play nice with promisify() below.
const pbkdf2WithDigest = (password, salt, iterations, keylen, digest, callback) => pbkdf2(password, salt, iterations, keylen, digest, callback);
const pbkdf2Promise = promisify(pbkdf2WithDigest);
export async function pbkdf2DeriveBits(algorithm, baseKey, length) {
  const {
    iterations,
    hash,
    salt
  } = algorithm;
  const normalizedHash = normalizeHashName(hash);
  if (!normalizedHash) {
    throw lazyDOMException('hash cannot be blank', 'OperationError');
  }
  if (!iterations || iterations === 0) {
    throw lazyDOMException('iterations cannot be zero', 'OperationError');
  }
  if (!salt) {
    throw lazyDOMException(WRONG_SALT, 'OperationError');
  }
  const raw = baseKey.keyObject.export();
  if (length === 0) throw lazyDOMException('length cannot be zero', 'OperationError');
  if (length === null) throw lazyDOMException('length cannot be null', 'OperationError');
  if (length % 8) {
    throw lazyDOMException('length must be a multiple of 8', 'OperationError');
  }
  const sanitizedPassword = sanitizeInput(raw, WRONG_PASS);
  const sanitizedSalt = sanitizeInput(salt, WRONG_SALT);
  let result = await pbkdf2Promise(sanitizedPassword, sanitizedSalt, iterations, length / 8, normalizedHash);
  if (!result) {
    throw lazyDOMException('received bad result from pbkdf2()', 'OperationError');
  }
  return bufferLikeToArrayBuffer(result);
}
//# sourceMappingURL=pbkdf2.js.map